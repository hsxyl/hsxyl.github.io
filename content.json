{"meta":{"title":"xsb","subtitle":"","description":"","author":"hackX","url":"https://hsxyl.github.io/hsxyl.github.io","root":"/"},"pages":[{"title":"文章分类","date":"2020-04-23T10:11:31.000Z","updated":"2020-06-04T03:29:45.000Z","comments":true,"path":"categories/index.html","permalink":"https://hsxyl.github.io/hsxyl.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-04-23T10:15:57.000Z","updated":"2020-06-04T03:29:45.000Z","comments":true,"path":"tags/index.html","permalink":"https://hsxyl.github.io/hsxyl.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"记aop内部调用不生效","slug":"记aop内部调用不生效","date":"2020-06-20T07:32:56.000Z","updated":"2020-06-20T07:32:56.000Z","comments":true,"path":"2020/06/20/记aop内部调用不生效/","link":"","permalink":"https://hsxyl.github.io/hsxyl.github.io/2020/06/20/%E8%AE%B0aop%E5%86%85%E9%83%A8%E8%B0%83%E7%94%A8%E4%B8%8D%E7%94%9F%E6%95%88/","excerpt":"","text":"工作记录 需求: 有一个执行任务的功能，需要持久化任务的执行状态。 为什么用aop: 执行任务的功能和记录任务状态变化的功能如果是耦合的，就会在执行任务的逻辑里面添加一堆if..else去判断任务的状态然后添加持久化的逻辑，代码可读性，维护性都很差，所以采用aop+注解的方式去解耦。 遇到的问题: 非接口定义的方法没有被代理 原因是spring的aop动态代理底层有两层实现：基于JDK的和基于gclib的，两者的一个重要区别在于JDK代理只能代理接口定义的方法，gclib则无该限制，对于接口实现类会默认使用基于JDK的动态代理。 使用了gclib后，内部调用方法无法被代理 gclib动态代理的大致原理是创建一个被代理类的子类，通过实现父类的非final方法实现拦截监听的.(也就是说方法具体的实现gclib管不着只是在执行前后帮你生成了一些代码，所以内部的调用他无能为力) 代码实例 定义service和给出实现，实现类里面存着内部调用关系：123456789101112@Servicepublic class AopDemoServiceImpl implements AopDemoService &#123; @Override public void method1() &#123; System.out.println(\"I am method1\"); method2(); &#125; public void method2() &#123; System.out.println(\"I am method2\"); &#125;&#125; 定义切点和通知来监听实现类的两个方法：12345678910@Pointcut(value = \"execution(* com.example.demo.service.AopDemoServiceImpl.*(..))\")public void demoPointCut() &#123;&#125;@Around(value = \"demoPointCut()\")public void demoAroud(ProceedingJoinPoint pjp) throws Throwable &#123; // 输出方法名 System.out.println(\"before method:\"+pjp.getSignature()); pjp.proceed(); System.out.println(\"after method:\"+pjp.getSignature());&#125; 编写一个测试类来看看调用AopDemoServiceImpl.method1()会发生什么：1234567@Autowiredpublic AopDemoService aopDemoService;@Testpublic void aopTest() &#123; aopDemoService.method1();&#125; 我们期望的情况应该是aop里面的提示信息环绕着方法的执行被打印出来,如下：123456before method:void com.example.demo.service.AopDemoServiceImpl.method1()I am method1before method:void com.example.demo.service.AopDemoServiceImpl.method2()I am method2after method:void com.example.demo.service.AopDemoServiceImpl.method2()after method:void com.example.demo.service.AopDemoServiceImpl.method1() 然而实际输出的确是：1234before method:void com.example.demo.service.AopDemoServiceImpl.method1()I am method1I am method2after method:void com.example.demo.service.AopDemoServiceImpl.method1() 原因上文也提到了，gclib生成被代理对象的子类，重写子类的非final方法，但是并非去重写方法的具体细节，而是在方法的前后增加了逻辑，然后再去调用原本的方法，所以对于内部的调用gclib无能为力。 解决方案 第一种思路是，既然代理类无法感知到内部调用，那我们修改原本的内部调用，去调用代理类生成后的方法\b。 1.1 使用AopContext.currentProxy()去获取代理类： 12345678910@Override public void method1() &#123; System.out.println(\"I am method1\"); // 另外注意：要设置aop实体暴露出来。在springboot的入口类里面加上@EnableAspectJAutoProxy(proxyTargetClass = true, exposeProxy = true) ((AopDemoServiceImpl) AopContext.currentProxy()).method2(); &#125; public void method2() &#123; System.out.println(\"I am method2\"); &#125; 1.2 将代理类生成后注入进来: 从ApplicationContext获取代理对象: 1234567891011@Autowiredprivate ApplicationContext context;private AopDemoServiceImpl proxyObject;@PostConstruct// 初始化方法，在IOC注入完成后会执行该方法private void setSelf() &#123; // 从spring上下文获取代理对象（直接通过proxyObject=this是不对的，this是目标对象） // 此种方法不适合于prototype Bean，因为每次getBean返回一个新的Bean proxyObject = context.getBean(AopDemoServiceImpl.class);&#125; 或者使用@Lazy注解去延迟加载： 1234567private AopDemoServiceImpl proxyObject;@Autowired@Lazypublic void setTestService(AopDemoServiceImpl proxyObject) &#123; this.proxyObject &#x3D; proxyObject;&#125; 使用aspectJ织入，aspectJ直接在源类上进行字节码增强，而非代理的方式去实现aop。 Todo 目前只是从别人的博客上看懂了这g过程，需要深入研究gclib生成过程，学习java编译过程原理，查看gclib生成的class文件，找到实际的证据。 学习AspectJ AopContext.currentProxy()是如何实现的 延迟加载注解的原理 参考 CGLIB(Code Generation Library)详解 spring aop问题解决","categories":[],"tags":[]},{"title":"test","slug":"test","date":"2020-06-04T04:04:07.000Z","updated":"2020-06-04T04:04:07.000Z","comments":true,"path":"2020/06/04/test/","link":"","permalink":"https://hsxyl.github.io/hsxyl.github.io/2020/06/04/test/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-06-04T03:29:51.000Z","updated":"2020-06-04T03:29:51.000Z","comments":true,"path":"2020/06/04/hello-world/","link":"","permalink":"https://hsxyl.github.io/hsxyl.github.io/2020/06/04/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hello","slug":"hello","permalink":"https://hsxyl.github.io/hsxyl.github.io/categories/hello/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://hsxyl.github.io/hsxyl.github.io/tags/jQuery/"}]}],"categories":[{"name":"hello","slug":"hello","permalink":"https://hsxyl.github.io/hsxyl.github.io/categories/hello/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://hsxyl.github.io/hsxyl.github.io/tags/jQuery/"}]}